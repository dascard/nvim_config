local bo = vim.bo
local fn = vim.fn

-- ‰∏çËßÑÂàôÁ©∫ÁôΩÊ£ÄÊµãÂáΩÊï∞
local function irregularWhitespace()
	-- USER CONFIG
	-- filetypes and the number of spaces they use. Omit or set to nil to use tabs for that filetype.
	local spaceFiletypes = { python = 4, yaml = 2 }
	local ignoredFiletypes = { "css", "markdown", "gitcommit" }
	local linebreakType = "unix" ---@type "unix" | "mac" | "dos"

	-- vars & guard
	local usesSpaces = bo.expandtab
	local usesTabs = not bo.expandtab
	local brUsed = bo.fileformat
	local ft = bo.filetype
	local width = bo.tabstop
	if vim.tbl_contains(ignoredFiletypes, ft) or fn.mode() ~= "" then
		return ""
	end

	-- non-default indentation setting (e.g. changed via indent-o-matic)
	local nonDefaultSetting = ""
	local spaceFtsOnly = vim.tbl_keys(spaceFiletypes)
	if (usesSpaces and not vim.tbl_contains(spaceFtsOnly, ft)) or (usesSpaces and width ~= spaceFiletypes[ft]) then
		nonDefaultSetting = " " .. tostring(width) .. "Û±Åê  "
	elseif usesTabs and vim.tbl_contains(spaceFtsOnly, ft) then
		nonDefaultSetting = " Û∞åí " .. tostring(width)
	end

	-- wrong or mixed indentation
	local hasTabs = fn.search("^\t", "nw") > 0
	local hasSpaces = fn.search("^ ", "nw") > 0
	-- exception, jsdocs: space not followed by "*"
	if bo.filetype == "javascript" then
		hasSpaces = fn.search([[^ \(\*\)\@!]], "nw") > 0
	end
	local wrongIndent = ""
	if usesTabs and hasSpaces then
		wrongIndent = " Û±Åê "
	elseif usesSpaces and hasTabs then
		wrongIndent = " Û∞åí "
	elseif hasTabs and hasSpaces then
		wrongIndent = " Û±Åê + Û∞åí "
	end

	-- line breaks
	local linebreakIcon = ""
	if brUsed ~= linebreakType then
		if brUsed == "unix" then
			linebreakIcon = " Û∞åë "
		elseif brUsed == "mac" then
			linebreakIcon = " Û∞åë "
		elseif brUsed == "dos" then
			linebreakIcon = " Û∞åë "
		end
	end

	return nonDefaultSetting .. wrongIndent .. linebreakIcon
end

-- Â≠óÁ¨¶ÁªüËÆ°ÂáΩÊï∞
local function count_eng_zh_chars(text)
	local eng_count = 0
	local zh_count = 0
	local digit_count = 0

	if not text or text == "" then
		return 0, 0, 0
	end

	-- Count English letters (ASCII a-z, A-Z)
	eng_count = select(2, text:gsub("[a-zA-Z]", ""))

	-- Count digits (0-9)
	digit_count = select(2, text:gsub("[0-9]", ""))

	-- Count likely Chinese characters in the CJK Unified Ideographs block (U+4E00 to U+9FFF)
	zh_count = select(2, text:gsub("[\xE4-\xE9][\x80-\xBF][\x80-\xBF]", ""))

	return eng_count, zh_count, digit_count
end

-- Ëé∑ÂèñÂèØËßÜÈÄâÊã©ÊñáÊú¨
local function get_visual_selection()
	local mode = vim.fn.mode()

	-- Ê£ÄÊü•ÊòØÂê¶Âú®ÂèØËßÜÊ®°Âºè‰∏ã
	if not (mode == "v" or mode == "V" or mode == "\22") then
		return ""
	end

	-- Ëé∑ÂèñËµ∑ÂßãÂíåÁªìÊùü‰ΩçÁΩÆ
	local start_pos = vim.fn.getpos("v")
	local end_pos = vim.fn.getpos(".")

	-- Ëß£ÂåÖ‰ΩçÁΩÆ‰ø°ÊÅØ
	local s_line, s_col = start_pos[2], start_pos[3]
	local e_line, e_col = end_pos[2], end_pos[3]

	-- Á°Æ‰øùËµ∑Âßã‰ΩçÁΩÆÂú®ÁªìÊùü‰ΩçÁΩÆ‰πãÂâç
	if s_line > e_line or (s_line == e_line and s_col > e_col) then
		s_line, e_line = e_line, s_line
		s_col, e_col = e_col, s_col
	end

	local lines = vim.api.nvim_buf_get_lines(0, s_line - 1, e_line, false)
	if #lines == 0 then
		return ""
	end

	-- Â§ÑÁêÜÈÄâÊã©ÁöÑÊñáÊú¨
	if #lines == 1 then
		-- ÂçïË°åÈÄâÊã©
		return lines[1]:sub(s_col, e_col)
	else
		-- Â§öË°åÈÄâÊã©
		lines[1] = lines[1]:sub(s_col)
		lines[#lines] = lines[#lines]:sub(1, e_col)
		return table.concat(lines, "\n")
	end
end

-- ÈÄâÊã©ËÆ°Êï∞ÊòæÁ§∫
local function selectionCount()
	local mode = vim.fn.mode()

	-- Âè™Âú®ÂèØËßÜÊ®°Âºè‰∏ãÊòæÁ§∫ËÆ°Êï∞
	if not (mode == "v" or mode == "V" or mode == "\22") then
		return ""
	end

	local text = get_visual_selection()
	if text == "" then
		return ""
	end

	local eng_count, zh_count, digit_count = count_eng_zh_chars(text)
	local total_chars = vim.fn.strchars(text)
	local other_chars = total_chars - eng_count - zh_count - digit_count

	-- ËøîÂõûÊ†ºÂºèÂåñÁöÑËÆ°Êï∞‰ø°ÊÅØÔºå‰ΩøÁî®Êõ¥ÁæéËßÇÁöÑÂõæÊ†áÂíåÊ†ºÂºè
	local result_parts = {}

	if eng_count > 0 then
		table.insert(result_parts, string.format("üî§%d", eng_count))
	end

	if zh_count > 0 then
		table.insert(result_parts, string.format("üÄÑ%d", zh_count))
	end

	if digit_count > 0 then
		table.insert(result_parts, string.format("üî¢%d", digit_count))
	end

	if other_chars > 0 then
		table.insert(result_parts, string.format("üìù%d", other_chars))
	end

	if #result_parts == 0 then
		return string.format("üìÑ%d", total_chars)
	end

	return table.concat(result_parts, " ")
end

return {
	-- È¢úËâ≤ÊñπÊ°à
	{
		"folke/tokyonight.nvim",
		lazy = false,
		priority = 1000,
		opts = {
			style = "night",
			transparent = true,
			terminal_colors = true,
			styles = {
				comments = { italic = true },
				keywords = { italic = true },
				functions = {},
				variables = {},
				sidebars = "transparent",
				floats = "transparent",
			},
		},
		config = function(_, opts)
			require("tokyonight").setup(opts)
			vim.cmd.colorscheme("tokyonight")
		end,
	},

	-- Áä∂ÊÄÅÊ†è
	{
		"nvim-lualine/lualine.nvim",
		dependencies = { "nvim-tree/nvim-web-devicons", "f-person/git-blame.nvim" },
		config = function()
			local git_blame = require("gitblame")
			vim.g.gitblame_display_virtual_text = 0

			require("lualine").setup({
				options = {
					theme = "tokyonight",
					transparent = true,
					component_separators = { left = "", right = "" },
				},
				sections = {
					lualine_a = { "mode" },
					lualine_b = { "branch", "diff" },
					lualine_c = {
						{ "filename", path = 1 },
						{ "filesize" },
						{
							function()
								local mode = vim.fn.mode()
								if mode == "v" or mode == "V" or mode == "\22" then
									-- ÂèØËßÜÊ®°Âºè‰∏ãÊòæÁ§∫ÈÄâÊã©Âå∫ÂüüÁöÑÂ≠óÁ¨¶ÁªüËÆ°
									return selectionCount()
								else
									-- ÊôÆÈÄöÊ®°Âºè‰∏ãÊòæÁ§∫Êï¥‰∏™Êñá‰ª∂ÁöÑÂ≠óÁ¨¶ÁªüËÆ°
									local content = table.concat(vim.api.nvim_buf_get_lines(0, 0, -1, false), "\n")
									local eng_count, zh_count, digit_count = count_eng_zh_chars(content)
									local total_chars = vim.fn.strchars(content)
									local other_chars = total_chars - eng_count - zh_count - digit_count

									local result_parts = {}

									if eng_count > 0 then
										table.insert(result_parts, string.format("üî§%d", eng_count))
									end

									if zh_count > 0 then
										table.insert(result_parts, string.format("üÄÑ%d", zh_count))
									end

									if digit_count > 0 then
										table.insert(result_parts, string.format("üî¢%d", digit_count))
									end

									if other_chars > 0 then
										table.insert(result_parts, string.format("üìù%d", other_chars))
									end

									if #result_parts == 0 then
										return string.format("üìÑ%d", total_chars)
									end

									return table.concat(result_parts, " ")
								end
							end,
							color = { fg = "#8be9fd" },
						},
						{ git_blame.get_current_blame_text, cond = git_blame.is_blame_text_available },
					},
					lualine_x = {
						"os.date('%Y-%m-%d %H:%M:%S')",
						"encoding",
						"fileformat",
						"filetype",
						{
							"diagnostics",
							symbols = { error = "Û∞Öö ", warn = " ", info = "Û∞ãΩ ", hint = "Û∞ò• " },
						},
						{ irregularWhitespace },
					},
					lualine_y = { "progress" },
					lualine_z = { "location" },
				},
			})
		end,
	},

	-- Êñá‰ª∂Ê†ë
	{
		"nvim-tree/nvim-tree.lua",
		dependencies = { "nvim-tree/nvim-web-devicons" },
		cmd = "NvimTreeToggle",
		keys = { { "<leader>e", "<CMD>NvimTreeToggle<CR>" } },
		config = function()
			local function my_on_attach(bufnr)
				local api = require("nvim-tree.api")

				local function opts(desc)
					return { desc = "nvim-tree: " .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
				end

				-- default mappings
				api.config.mappings.default_on_attach(bufnr)

				-- custom mappings
				vim.keymap.set("n", "<C-t>", api.tree.change_root_to_parent, opts("Up"))
				vim.keymap.set("n", "?", api.tree.toggle_help, opts("Help"))
				vim.keymap.set("n", "<BS>", api.tree.change_root_to_parent, opts("Up"))
				vim.keymap.set("n", "l", api.node.open.edit, opts("Open"))
				vim.keymap.set("n", "h", api.node.navigate.parent_close, opts("Close Directory"))
				vim.keymap.set("n", "o", api.node.open.vertical, opts("Open: Vertical Split"))
			end

			require("nvim-tree").setup({
				sort_by = "case_sensitive",
				hijack_cursor = true,
				system_open = {
					cmd = "open",
				},
				view = {
					width = 30,
					side = "left",
					number = false,
					relativenumber = false,
					signcolumn = "yes",
				},
				actions = {
					open_file = {
						quit_on_open = false,
						resize_window = true,
					},
				},
				filters = {
					dotfiles = false,
					custom = { "node_modules" },
				},
				git = {
					enable = true,
					ignore = false,
				},
				update_focused_file = {
					enable = true,
					update_root = true,
				},
				on_attach = my_on_attach,
				renderer = {
					root_folder_label = false,
					highlight_git = true,
					indent_markers = { enable = true },
					special_files = {},
					icons = {
						show = {
							file = true,
							folder = true,
							folder_arrow = true,
							git = true,
						},
						glyphs = {
							default = "Û∞àö",
							symlink = "",
							bookmark = "Û∞Ü§",
							modified = "‚óè",
							-- folder = {
							-- 	arrow_closed = "ÔÅª",
							-- 	arrow_open = "ÔÅº",
							-- 	default = "Û∞âã",
							-- 	open = "ÔÅº",
							-- 	empty = "ÔÑî",
							-- 	empty_open = "ÔÑï",
							-- 	symlink = "ÔíÅ",
							-- 	symlink_open = "ÔíÇ",
							-- },
							git = {
								unstaged = "‚úó",
								staged = "‚úì",
								unmerged = "",
								renamed = "‚ûú",
								untracked = "‚òÖ",
								deleted = "",
								ignored = "‚óå",
							},
						},
						webdev_colors = true,
						git_placement = "before",
						padding = " ",
						symlink_arrow = " ‚ûõ ",
					},
					highlight_opened_files = "none",
					root_folder_modifier = ":~",
					add_trailing = false,
				},
			})
		end,
	},

	-- Git blame
	{
		"f-person/git-blame.nvim",
		event = "VeryLazy",
		opts = {
			enabled = true,
			message_template = " <summary> ‚Ä¢ <date> ‚Ä¢ <author> ‚Ä¢ <<sha>>",
			date_format = "%m-%d-%Y %H:%M:%S",
			virtual_text_column = 1,
		},
	},

	-- ÈîôËØØÂàóË°®
	{
		"folke/trouble.nvim",
		opts = {
			modes = {
				lsp = {
					win = { position = "right" },
				},
			},
			keys = {
				["<esc>"] = "close",
			},
		},
	},

	-- ÁºìÂÜ≤Âå∫Ê†áÁ≠æÈ°µ
	{
		"akinsho/bufferline.nvim",
		event = "VeryLazy",
		keys = {
			{ "<leader>bp", "<Cmd>BufferLineTogglePin<CR>", desc = "Toggle Pin" },
			{ "<leader>bP", "<Cmd>BufferLineGroupClose ungrouped<CR>", desc = "Delete Non-Pinned Buffers" },
			{ "<leader>br", "<Cmd>BufferLineCloseRight<CR>", desc = "Delete Buffers to the Right" },
			{ "<leader>bl", "<Cmd>BufferLineCloseLeft<CR>", desc = "Delete Buffers to the Left" },
			{ "<S-h>", "<cmd>BufferLineCyclePrev<cr>", desc = "Prev Buffer" },
			{ "<S-l>", "<cmd>BufferLineCycleNext<cr>", desc = "Next Buffer" },
			{ "<leader>[", "<cmd>BufferLineCyclePrev<cr>", desc = "Prev Buffer" },
			{ "<leader>]", "<cmd>BufferLineCycleNext<cr>", desc = "Next Buffer" },
			{ "[B", "<cmd>BufferLineMovePrev<cr>", desc = "Move buffer prev" },
			{ "]B", "<cmd>BufferLineMoveNext<cr>", desc = "Move buffer next" },
			{ "H", "0", mode = { "n" } },
			{ "L", "$", mode = { "n" } },
		},
		opts = {
			options = {
				close_command = function(n)
					if package.loaded["snacks"] then
						Snacks.bufdelete(n)
					else
						vim.cmd("bdelete " .. n)
					end
				end,
				right_mouse_command = function(n)
					if package.loaded["snacks"] then
						Snacks.bufdelete(n)
					else
						vim.cmd("bdelete " .. n)
					end
				end,
				separator_style = "slant",
				indicator = {
					style = "underline",
				},
				buffer_close_icon = "Û∞Öñ",
				modified_icon = "‚óè ",
				close_icon = " ",
				left_trunc_marker = " ",
				right_trunc_marker = " ",
				diagnostics = "nvim_lsp",
				diagnostics_indicator = function(count, level)
					local icon = level:match("error") and " " or " "
					return " " .. icon .. count
				end,
				numbers = function(opts)
					return string.format(" %s/%s", vim.fn.tabpagenr(), opts.ordinal)
				end,
				hover = {
					enabled = true,
					delay = 200,
					reveal = { "close" },
				},
				pick = {
					alphabet = "abcdefghijklmopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ1234567890",
				},
				max_name_length = 18,
				tab_size = 18,
				offsets = {
					{
						filetype = "NvimTree",
						text = "Explorer",
						highlight = "Directory",
						text_align = "left",
					},
				},
			},
			highlights = {
				background = {
					bg = "NONE",
				},
				buffer_selected = {
					bg = "NONE",
				},
				buffer_visible = {
					bg = "NONE",
				},
				close_button = {
					bg = "NONE",
				},
				close_button_visible = {
					bg = "NONE",
				},
				close_button_selected = {
					bg = "NONE",
				},
				fill = {
					bg = "NONE",
				},
				separator = {
					bg = "NONE",
				},
				separator_selected = {
					bg = "NONE",
				},
				separator_visible = {
					bg = "NONE",
				},
				tab = {
					bg = "NONE",
				},
				tab_selected = {
					bg = "NONE",
				},
				tab_close = {
					bg = "NONE",
				},
				duplicate_selected = {
					bg = "NONE",
				},
				duplicate_visible = {
					bg = "NONE",
				},
				duplicate = {
					bg = "NONE",
				},
			},
		},
		config = function(_, opts)
			require("bufferline").setup(opts)
			vim.api.nvim_create_autocmd({ "BufAdd", "BufDelete" }, {
				callback = function()
					vim.schedule(function()
						pcall(require, "bufferline")
					end)
				end,
			})
		end,
	},

	-- Ê†áÁ≠æÈ°µ‰ΩúÁî®Âüü
	{
		"tiagovla/scope.nvim",
		config = function()
			require("scope").setup({})
		end,
		keys = {
			{ "<M-n>", "<CMD>tabnext<CR>" },
			{ "<M-p>", "<CMD>tabprevious<CR>" },
		},
	},

	-- ÈÄöÁü•Á≥ªÁªü
	-- ...existing code...
	-- ÈÄöÁü•Á≥ªÁªü
	{
		"folke/noice.nvim",
		event = "VeryLazy",
		opts = {
			lsp = {
				override = {
					["cmp.entry.get_documentation"] = true,
				},
			},
			routes = {
				{
					filter = {
						event = "msg_show",
						any = {
							{ find = "%d+L, %d+B" },
							{ find = "; after #%d+" },
							{ find = "; before #%d+" },
						},
					},
					view = "mini",
				},
				{
					filter = {
						event = "msg_show",
						any = {
							{ find = "Agent service not initialized" },
						},
					},
					opts = { skip = true },
				},
			},
			presets = {
				bottom_search = false, -- Á¶ÅÁî®Â∫ïÈÉ®ÊêúÁ¥¢Ôºå‰ΩøÁî®ÂºπÂá∫Âºè
				command_palette = true, -- ÂêØÁî®ÂëΩ‰ª§Èù¢Êùø
				long_message_to_split = true,
			},
			cmdline = {
				enabled = true, -- ÂêØÁî®ÂëΩ‰ª§Ë°å
				view = "cmdline_popup", -- ÊÅ¢Â§ç‰ΩøÁî®ÂºπÂá∫ÂºèÂëΩ‰ª§Ë°å
				opts = {}, -- ÂÖ®Â±ÄcmdlineÈÄâÈ°π
				format = {
					-- ÂëΩ‰ª§Ê®°Âºè
					cmdline = { pattern = "^:", lang = "vim" },
					-- ÊêúÁ¥¢Ê®°ÂºèÔºàÂêë‰∏ãÊêúÁ¥¢Ôºâ
					search_down = { kind = "search", pattern = "^/", lang = "regex" },
					-- ÊêúÁ¥¢Ê®°ÂºèÔºàÂêë‰∏äÊêúÁ¥¢Ôºâ
					search_up = { kind = "search", pattern = "^%?", lang = "regex" },
					-- ËøáÊª§Ê®°Âºè
					filter = { pattern = "^:%s*!", lang = "bash" },
					-- LuaÊ®°Âºè
					lua = { pattern = "^:%s*lua%s+", lang = "lua" },
					-- Â∏ÆÂä©Ê®°Âºè
					help = { pattern = "^:%s*he?l?p?%s+" },
					-- ËæìÂÖ•Ê®°Âºè
					input = {},
				},
			},
			messages = {
				-- Ê≥®ÊÑèÔºöÂ¶ÇÊûúÂêØÁî®messagesÔºåÊüê‰∫õÂÜÖÂÆπÂèØËÉΩ‰ºöÈáçÂ§çÊòæÁ§∫
				enabled = true, -- ÂêØÁî®Ê∂àÊÅØ
				view = "notify", -- ÈªòËÆ§ËßÜÂõæ
				view_error = "notify", -- ÈîôËØØÊ∂àÊÅØËßÜÂõæ
				view_warn = "notify", -- Ë≠¶ÂëäÊ∂àÊÅØËßÜÂõæ
				view_history = "messages", -- :messagesÁöÑËßÜÂõæ
				view_search = "virtualtext", -- ÊêúÁ¥¢ËÆ°Êï∞Ê∂àÊÅØ
			},
			popupmenu = {
				enabled = true, -- ÂêØÁî®ÂºπÂá∫ËèúÂçï
				backend = "nui", -- ‰ΩøÁî®ÂéüÁîüÂêéÁ´ØÊòæÁ§∫Ë°•ÂÖ®
				kind_icons = {}, -- Á¶ÅÁî®ÂõæÊ†á
			},
			-- Ëá™ÂÆö‰πâËßÜÂõæÈÖçÁΩÆ
			views = {
				cmdline_popup = {
					position = {
						row = "50%", -- ÂûÇÁõ¥Â±Ö‰∏≠
						col = "50%", -- Ê∞¥Âπ≥Â±Ö‰∏≠
					},
					size = {
						width = 60, -- ÂëΩ‰ª§Ë°åÂÆΩÂ∫¶
						height = "auto",
					},
					border = {
						style = "rounded",
						padding = { 0, 1 },
					},
					filter_options = {},
					win_options = {
						winhighlight = "NormalFloat:NormalFloat,FloatBorder:FloatBorder",
						winblend = 25, -- Â¢ûÂä†ÂëΩ‰ª§Ê°ÜÈÄèÊòéÂ∫¶
					},
				},
				popupmenu = {
					relative = "editor", -- Áõ∏ÂØπ‰∫éÁºñËæëÂô®ÂÆö‰Ωç
					position = {
						row = "70%", -- ‰ΩçÁΩÆÂú®Â±èÂπï‰∏ãÊñπ70%Â§ÑÔºåÁ°Æ‰øùÂú®ÂëΩ‰ª§Ê°Ü‰∏ãÊñπ
						col = "50%", -- Ê∞¥Âπ≥Â±Ö‰∏≠
					},
					size = {
						width = 60,
						height = 15, -- ÊòæÁ§∫Êõ¥Â§öÈÄâÈ°π
					},
					border = {
						style = "rounded",
						padding = { 0, 1 },
					},
					win_options = {
						winhighlight = "NormalFloat:NormalFloat,FloatBorder:FloatBorder",
						winblend = 25, -- Â¢ûÂä†ÈÄèÊòéÂ∫¶
					},
				},
			},
		},
		dependencies = {
			"MunifTanjim/nui.nvim",
			"rcarriga/nvim-notify",
		},
	},

	-- ÂõæÊ†á
	{
		"echasnovski/mini.icons",
		lazy = true,
		opts = {
			file = {
				[".keep"] = { glyph = "Û∞ä¢", hl = "MiniIconsGrey" },
				["devcontainer.json"] = { glyph = "", hl = "MiniIconsAzure" },
				[".gitignore"] = { glyph = "", hl = "MiniIconsOrange" },
				[".env"] = { glyph = "", hl = "MiniIconsYellow" },
				["README.md"] = { glyph = "", hl = "MiniIconsBlue" },
				["package.json"] = { glyph = "", hl = "MiniIconsGreen" },
				["tsconfig.json"] = { glyph = "", hl = "MiniIconsBlue" },
			},
			filetype = {
				dotenv = { glyph = "", hl = "MiniIconsYellow" },
				git = { glyph = "", hl = "MiniIconsOrange" },
				lua = { glyph = "", hl = "MiniIconsBlue" },
				python = { glyph = "", hl = "MiniIconsYellow" },
				javascript = { glyph = "", hl = "MiniIconsYellow" },
				typescript = { glyph = "", hl = "MiniIconsBlue" },
				rust = { glyph = "", hl = "MiniIconsRed" },
				go = { glyph = "", hl = "MiniIconsCyan" },
				json = { glyph = "", hl = "MiniIconsYellow" },
				yaml = { glyph = "", hl = "MiniIconsRed" },
				markdown = { glyph = "", hl = "MiniIconsBlue" },
			},
			directory = {
				[".git"] = { glyph = "", hl = "MiniIconsOrange" },
				[".github"] = { glyph = "", hl = "MiniIconsGrey" },
				["node_modules"] = { glyph = "", hl = "MiniIconsGreen" },
				["src"] = { glyph = "", hl = "MiniIconsBlue" },
				["lib"] = { glyph = "", hl = "MiniIconsPurple" },
				["config"] = { glyph = "", hl = "MiniIconsYellow" },
				["docs"] = { glyph = "", hl = "MiniIconsBlue" },
				["test"] = { glyph = "Û∞ô®", hl = "MiniIconsRed" },
				["tests"] = { glyph = "Û∞ô®", hl = "MiniIconsRed" },
			},
		},
		init = function()
			package.preload["nvim-web-devicons"] = function()
				require("mini.icons").mock_nvim_web_devicons()
				return package.loaded["nvim-web-devicons"]
			end
		end,
		config = function(_, opts)
			require("mini.icons").setup(opts)
		end,
	},
}
